<element name="smart-list">
  <template>
    <content></content>
  </template>
  <script>
    Polymer.register(this, {
      get items() {
        return this.children;
      },
      push: function(node, props) {
        this.insert(this.items.length, node, props);
      },
      unshift: function(node, props) {
        this.insert(0, node, props);
      },
      insert: function(i, node, props) {
        if (typeof node === "string") node = document.createElement(node);
        if (props) {
          for (prop in props) {
            node[prop] = props[prop];
          }
        }

        if (i >= this.items.length) {
          this.appendChild(node);
        } else {
          this.insertBefore(node, this.items[i]);
        }

        this.showItem(i);
      },
      showItem: function(i) {
        var node = this.items[i];

        node.style["z-index"] = -i;
        node.style.position = "relative";
        node.style["margin-top"] = (-parseInt(node.clientHeight, 10)) + "px";
        setTimeout(function() {
          node.style.transition = "margin-top 1s";
          node.style["margin-top"] = "0px";
        }, 0);
      },
      get: function(id) {
        return this.querySelector("#" + id);
      },
      rm: function(id) {
        var el = this.get(id);
        if (el) {
          this.removeChild(el);
        }
      },
      rmByIndex: function(index) {
        var el = this.items[index];
        if (el) {
          this.removeChild(el);
        }
      }
    });
  </script>
</element>

<element name="racer-element" attributes="at">
  <template>
    <content></content>
  </template>
  <script>
    Polymer.register(this, {
  trigger: function() {
    var name = arguments[0],
    data = [].slice.call(arguments, 1),
    fname,
    on;

    fname = name.split(":").map(function(word) {
      return word.charAt(0).toUpperCase() + word.slice(1);
    }).join("");

    if (on = this["on" + fname]) {
      on.apply(this, data);
    }
    this.fire(name, data);
  },
  on: function(type, cb) {
    this.addEventListener(type, function(e) {
      cb.apply({}, e.detail);
    });
  },
  set child(element) {
    while (this.firstElementChild) {
      this.removeChild(this.firstElementChild);
    }
    this.appendChild(element);

    this.update();
  },
  get child() {
    return this.firstElementChild;
  },
  set racer(racer) {
    var self = this;
    racer.ready(function(model) {
      self.model = model;
    });
  },
  set model(model) {
    var self = this;
    this._model = model;

    if (!this.child) {
      this.child = document.createElement(this.childType || "div");
      if (!this.child.model) this.child.model = {};
    }

    this.listen();

    if (model.get(this.at)) {
      this.trigger("model:load");
    } else {
      model.subscribe(this.at, function() {
        self.trigger("model:load");
      });
    }
  },
  get model() {
    return this._model;
  },
  resolve: function(path) {
    var resolved = [];
    if (this.at) resolved.push(this.at);
    if (path) resolved.push(path);
    return resolved.length > 0 ? resolved.join(".") : null;
  },
  del: function(path) {
    this._model.del(this.resolve(path));
    this.fire("delete");
  },
  set: function(key, value) {
    this._model.set(this.resolve(key), value);
  },
  onChildSave: function() {
    this.save();
  },
  onChildDelete: function() {
    this.del();
  },
  listen: function() {
    var self = this;

    if (!this.turbo) {
      this.child.addEventListener("save", function(e) {
        e.stopPropagation();
        self.onChildSave();
      });
    }
    this.child.addEventListener("delete", function(e) {
      e.stopPropagation();
      self.onChildDelete();
    });

    this._model.on("all", "**", function(path, ev, data, oldData) {
      var args = [ev, path, data, oldData];

      if (self.at && self.at !== "") {
        if (path.indexOf(self.at) !== 0) return;
        if (path === self.at) {
          args.splice(1, 1);
        } else {
          args[1] = args[1].replace(self.at + ".", "");
        }
      }
      self.trigger.apply(self, args);
    });
  },
  update: function(data) {
    var data,
    self = this,
    key;
    if (!this.child || !this.child.model || !this._model) return;
    data = data || this._model.get();

    for (key in data) {
      this.child.model[key] = data[key];
    }
  },
  save: function() {
    var key;
    for (key in this.child.model) {
      this.set(key, this.child.model[key]);
    }
    this.fire("save");
  },
  reset: function() {
    this.child.model = this._model.get(this.at);
  },
  onModelLoad: function() {
    this.update();
  },
  onChange: function(name, value) {
    if (!this.child) return;
    this.child.model[name] = value;
  }
});

  </script>
</element>

<element name="racer-list" extends="racer-element" attributes="itemType at reverse itemAttributes">
  <script>
    Polymer.register(this, {
      _authoredLocally: {},

      ready: function() {
        this.appendChild(document.createElement("smart-list"));
      },
      get list() {
        return this.child;
      },
      get items() {
        return this.list.items;
      },
      add: function(key) {
        var wrapper = document.createElement("racer-element"),
        attr;

        if (!this.itemType) throw new Error("itemType was not declared");
        wrapper.child = document.createElement(this.itemType);
        wrapper.model = this._model.at(this.at + "." + key);
        if (this.itemAttributes) {
          for (attr in this.itemAttributes) {
            wrapper.child[attr] = this.itemAttributes[attr];
          }
        }

        wrapper.id = "r-" + key;

        if (this._isArray) {
          if (this.reverse) {
            key = this.items.length - key;
          }
          this.list.insert(key, wrapper);
        } else {
          this.list[this.reverse ? "unshift" : "push"](wrapper);
        }
      },
      push: function(item) {
        var length = this.items.length;

        if (this._isArray) {
          this.insert(this.items.length, item);
        } else {
          while (this._model.get(this.at + "." + length)) {
            length += 1;
          }
          this.set(length, item);
        }
      },
      unshift: function(item) {
        if (!this._isArray) throw new Error("Can't unshift on an object!");
        this.insert(0, item);
      },
      insert: function(i, model) {
        if (!this._isArray) throw new Error("Can't insert on an object!");
        this._authoredLocally[i] = true;
        this._model.insert(this.at, i, model || {});
      },
      set: function(key, model) {
        this._authoredLocally[key] = true;
        this._model.set(this.at + "." + key, model);
      },
      get: function(id) {
        return this.list.get("r-" + id);
      },
      del: function(key) {
        if (this._isArray) {
          this._model.del(this.at, key, 1);
        } else {
          this._model.del(this.at + "." + key);
        }
      },
      onModelLoad: function() {
        var key,
        data,
        self = this;

        if (!this.at) throw new Error("at attribute must be specified");
        data = this._model.get(this.at);

        this._isArray = Array.isArray(data);

        if (data) {
          Object.keys(data).forEach(function(key) {
            self.add(key);
          });
        }

        this.trigger("items:load");
      },
      onItemDelete: function(key) {
        this._authoredLocally[key] = false;
        this.list.rm("r-" + key);
      },
      onItemCreate: function(key) {
        this.add(key);
      },
      onForeignItemCreate: function(key) {
        this.add(key);
      },
      onItemUpdate: function(key, data) {
        var item;

        if (this._isArray) {
          item = this.list.items[key];
        } else {
          item = this.get(key);
        }
        item.update(data);
      },
      onChange: function(key, data) {
        var ev = "";

        if (this._isArray) {
          ev = "update";
        } else {
          if (key.indexOf(".") > -1) return;
          if (data) {
            if (this.get(key)) {
              ev = "update";
            } else {
              return; //create will be catched by load.
            }
          } else {
            ev = "delete";
          }
        }

        this.trigger("item:" + ev, key, data);
      },
      onLoad: function(key) {
        var ev = "item:create";
        if (this._isArray || this.get(key)) return;
        if (!this._authoredLocally[key]) {
          ev = "foreign:" + ev;
        }
        this.trigger(ev, key);
      },
      onInsert: function(i) {
        this.trigger("item:create", i);
      },
      onRemove: function(i) {
        this.trigger("item:delete", i);
      },
      reset: function() {
        this.items.forEach(function(item) {
          item.reset();
        });
      }
    });
  </script>
</element>
