<element name="smart-collection">
  <template>
    <style>
      @host {}
    </style>  
  </template>
  <script>
    (function(context) {

      function add(el, nodeName, props) {
        var element = document.createElement(nodeName),
        prop;

        if (props) {
          for (prop in props) {
            element[prop] = props[prop];
          }
        }
        el.appendChild(element);
      }

      function addBatch(el, nodeName, num) {
        for (var i = 0; i < num; i++) {
          add(el, nodeName);
        }
      }

      function addBatchWithProps(el, nodeName, propsList) {
        propsList.forEach(function(props) {
          add(el, nodeName, props);
        });
      }

      Polymer.register(context, {
        add: function(nodeName, secondParam) {
          switch (typeof secondParam) {
            case "undefined":
              add(this, nodeName);
              break;
            case "number":
              addBatch(this, nodeName, secondParam);
              break;
            case "object":
              if (Object.prototype.toString.call(secondParam).indexOf("Array") > -1) {
                addBatchWithProps(this, nodeName, secondParam);
              } else {
                add(this, nodeName, secondParam);
              }
              break;
          }
        },
        get: function(id) {
          return this.querySelector("#" + id);
        },
        remove: function(id) {
          this.removeChild(this.get(id));
        }
      });
    })(this);
  </script>
</element>

<element name="racer-element" attributes="at">
  <template>
    <style>
      @host {}
    </style>  
  </template>
  <script>
    Polymer.register(this, {
      ready: function() {
        var racer = (this.parentNode && this.parentNode.racer) || window.racer;

        if (racer) {
          this.racer = racer;
        };
      },
      trigger: function() {
        var name = arguments[0],
        data = [].slice.call(arguments, 1),
        fname,
        on;

        fname = name.split(":").map(function(word) {
          return word.charAt(0).toUpperCase() + word.slice(1);
        }).join("");
        
        if (on = this["on" + fname]) {
          on.apply(this, data);
        }
        this.dispatchEvent(new Event(name, {detail: data}));
      },
      set racer(racer) {
        var self = this;
        racer.ready(function(model) {
          self.model = model;
        });
      },
      set child(element) {
        while (this.firstElementChild) {
          this.removeChild(this.firstElementChild);
        }
        this.appendChild(element);
        if (this._model) {
          this.update();
        }
      },
      get child() {
        return this.firstElementChild;
      },
      set model(model) {
        var self = this;
        if (this.at) {
          model = model.at(this.at);
        }
        this._model = model;

        model.on("all", "**", function(path, ev, data, oldData) {
          self.trigger(ev, path, data, oldData);
        });
        model.subscribe(function() {
          self.trigger("subscribe");
        });
      },
      get model() {
        return this._model;
      },
      update: function(data) {
        this.child.model = data || this._model.get();
      },
      onSubscribe: function() {
        if (this.child) {
          this.update();
        }
      },
      onChange: function(name, value) {
        if (!this.child || !this.child.model) return;
        this.child.model[name] = value;
      }
    });
  </script>
</element>

<element name="racer-collection" extends="racer-element">
  <template>
    <style>
      @host {}
    </style>  
    <smart-collection id="collection"></smart-collection>
  </template>
  <script>
    Polymer.register(this, {
      add: function(id) {
        var wrapper = document.createElement("racer-element"),
        self = this;

        if (!this.childType) throw new Error("childType was not declared");
        wrapper.child = document.createElement(this.childType);
        wrapper.addEventListener("subscribe", function() {
          self.trigger("item:subscribe");
        });
        wrapper.model = this._model.at(id);
        wrapper.id = id;
        this.$.collection.appendChild(wrapper);
      },
      onSubscribe: function() {
        var key,
        data = this._model.get(),
        count = Object.keys(data).length,
        subscribed = 0,
        self = this;

        for (key in data) {
          this.add(key);
        }

        this.addEventListener("item:subscribe", function() {
          subscribed++;
          if (subscribed >= count) {
            subscribed = 0;
            self.trigger("items:subscribe");
          }
        });
      },
      onItemDelete: function(id) {
        this.$.collection.remove(id);
      },
      onItemCreate: function(id) {
        this.add(id);
      },
      onItemUpdate: function(id, data) {
        this.$.collection.get(id).update(data);
      },
      onChange: function(id, data) {
        if (this.$.collection.get(id)) {
          if (data) {
            this.trigger("item:update", id, data);
          } else {
            this.trigger("item:delete", id);
          }
        } else {
          this.trigger("item:create", id);
        }
      }
    });
  </script>
</element>
